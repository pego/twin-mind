# Twin-Mind v1.1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add configuration system, incremental indexing, prune command, and UX improvements to Twin-Mind while maintaining single-file architecture.

**Architecture:** All changes go into `scripts/twin-mind.py`. Configuration loaded from `.claude/settings.json`. Index state tracked in `.claude/index-state.json`. No new dependencies (stdlib only).

**Tech Stack:** Python 3.8+, memvid-sdk, subprocess (git), fcntl (file locking)

---

## Task 1: Add Color and Output Helpers

**Files:**
- Modify: `scripts/twin-mind.py` (add after line 30, before helpers section)

**Step 1: Add ANSI color constants and helpers**

Add this code after the imports and before `# === Configuration ===`:

```python
# === Output Helpers ===
class Colors:
    """ANSI color codes for terminal output."""
    RESET = "\033[0m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    BOLD = "\033[1m"

    _enabled = True

    @classmethod
    def disable(cls):
        cls.RESET = cls.RED = cls.GREEN = ""
        cls.YELLOW = cls.BLUE = cls.BOLD = ""
        cls._enabled = False

    @classmethod
    def is_enabled(cls):
        return cls._enabled


def supports_color() -> bool:
    """Check if terminal supports color output."""
    import os
    if os.environ.get('NO_COLOR'):
        return False
    if not hasattr(sys.stdout, 'isatty'):
        return False
    return sys.stdout.isatty()


def color(text: str, color_code: str) -> str:
    """Wrap text in color code."""
    if not Colors._enabled:
        return text
    return f"{color_code}{text}{Colors.RESET}"


def success(msg: str) -> str:
    return color(msg, Colors.GREEN)


def warning(msg: str) -> str:
    return color(msg, Colors.YELLOW)


def error(msg: str) -> str:
    return color(msg, Colors.RED)


def info(msg: str) -> str:
    return color(msg, Colors.BLUE)
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add ANSI color output helpers"
```

---

## Task 2: Add Configuration System

**Files:**
- Modify: `scripts/twin-mind.py` (add after Colors class)

**Step 1: Add configuration loading functions**

Add after the output helpers:

```python
# === Configuration ===
DEFAULT_CONFIG = {
    "extensions": {
        "include": [],
        "exclude": []
    },
    "skip_dirs": [],
    "max_file_size": "500KB",
    "index": {
        "auto_incremental": True,
        "track_deletions": True
    },
    "output": {
        "color": True,
        "verbose": False
    }
}


def parse_size(size_str: str) -> int:
    """Parse size string like '500KB' to bytes."""
    size_str = size_str.strip().upper()
    multipliers = {'B': 1, 'KB': 1024, 'MB': 1024*1024, 'GB': 1024**3}
    for suffix, mult in multipliers.items():
        if size_str.endswith(suffix):
            return int(float(size_str[:-len(suffix)]) * mult)
    return int(size_str)


def load_config() -> dict:
    """Load twin-mind config from .claude/settings.json."""
    config = DEFAULT_CONFIG.copy()
    settings_path = get_brain_dir() / "settings.json"

    if settings_path.exists():
        try:
            with open(settings_path, 'r') as f:
                settings = json.load(f)
            if "twin-mind" in settings:
                user_config = settings["twin-mind"]
                # Merge extensions
                if "extensions" in user_config:
                    if "include" in user_config["extensions"]:
                        config["extensions"]["include"] = user_config["extensions"]["include"]
                    if "exclude" in user_config["extensions"]:
                        config["extensions"]["exclude"] = user_config["extensions"]["exclude"]
                # Merge skip_dirs
                if "skip_dirs" in user_config:
                    config["skip_dirs"] = user_config["skip_dirs"]
                # Other settings
                if "max_file_size" in user_config:
                    config["max_file_size"] = user_config["max_file_size"]
                if "index" in user_config:
                    config["index"].update(user_config["index"])
                if "output" in user_config:
                    config["output"].update(user_config["output"])
        except (json.JSONDecodeError, IOError) as e:
            print(warning(f"‚ö†Ô∏è  Config parse error: {e}. Using defaults."))

    return config


def get_extensions(config: dict) -> set:
    """Get final set of extensions to index."""
    extensions = CODE_EXTENSIONS.copy()
    for ext in config["extensions"]["include"]:
        extensions.add(ext if ext.startswith('.') else f'.{ext}')
    for ext in config["extensions"]["exclude"]:
        extensions.discard(ext if ext.startswith('.') else f'.{ext}')
    return extensions


def get_skip_dirs(config: dict) -> set:
    """Get final set of directories to skip."""
    skip = SKIP_DIRS.copy()
    for d in config["skip_dirs"]:
        skip.add(d)
    return skip


# Global config (loaded once)
_config_cache = None


def get_config() -> dict:
    """Get cached config."""
    global _config_cache
    if _config_cache is None:
        _config_cache = load_config()
    return _config_cache
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add configuration system via .claude/settings.json"
```

---

## Task 3: Add File Locking

**Files:**
- Modify: `scripts/twin-mind.py` (add after configuration section)

**Step 1: Add file locking helpers**

```python
# === File Locking ===
import time

if sys.platform == 'win32':
    import msvcrt
    def _lock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_NBLCK, 1)
    def _unlock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, 1)
else:
    import fcntl
    def _lock_file(f):
        fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
    def _unlock_file(f):
        fcntl.flock(f.fileno(), fcntl.LOCK_UN)


class FileLock:
    """Simple file-based lock with timeout."""

    def __init__(self, path: Path, timeout: int = 5):
        self.lock_path = Path(str(path) + '.lock')
        self.timeout = timeout
        self._lock_file = None

    def acquire(self) -> bool:
        """Acquire lock, return True if successful."""
        start = time.time()
        while time.time() - start < self.timeout:
            try:
                # Check for stale lock (>60s old)
                if self.lock_path.exists():
                    age = time.time() - self.lock_path.stat().st_mtime
                    if age > 60:
                        self.lock_path.unlink()

                self._lock_file = open(self.lock_path, 'w')
                _lock_file(self._lock_file)
                self._lock_file.write(str(os.getpid()))
                self._lock_file.flush()
                return True
            except (IOError, OSError):
                time.sleep(0.1)
        return False

    def release(self):
        """Release the lock."""
        if self._lock_file:
            try:
                _unlock_file(self._lock_file)
                self._lock_file.close()
                if self.lock_path.exists():
                    self.lock_path.unlink()
            except (IOError, OSError):
                pass
            self._lock_file = None

    def __enter__(self):
        if not self.acquire():
            raise IOError(f"Could not acquire lock on {self.lock_path} (timeout {self.timeout}s)")
        return self

    def __exit__(self, *args):
        self.release()
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add file locking for concurrent access safety"
```

---

## Task 4: Add Progress Indicator

**Files:**
- Modify: `scripts/twin-mind.py` (add after FileLock class)

**Step 1: Add progress bar helper**

```python
# === Progress ===
class ProgressBar:
    """Simple progress bar for terminal."""

    def __init__(self, total: int, width: int = 30, prefix: str = ""):
        self.total = total
        self.width = width
        self.prefix = prefix
        self.current = 0
        self._is_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()

    def update(self, n: int = 1):
        self.current += n
        if self._is_tty:
            self._render()

    def _render(self):
        pct = self.current / self.total if self.total > 0 else 1
        filled = int(self.width * pct)
        bar = '=' * filled + '>' + ' ' * (self.width - filled - 1)
        line = f"\r{self.prefix}[{bar}] {self.current}/{self.total} ({pct*100:.0f}%)"
        sys.stdout.write(line)
        sys.stdout.flush()

    def finish(self):
        if self._is_tty:
            sys.stdout.write('\n')
            sys.stdout.flush()
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add progress bar for indexing"
```

---

## Task 5: Add Git Integration Helpers

**Files:**
- Modify: `scripts/twin-mind.py` (add after ProgressBar)

**Step 1: Add git helper functions**

```python
# === Git Integration ===
import subprocess


def is_git_repo() -> bool:
    """Check if current directory is a git repo."""
    try:
        subprocess.run(
            ['git', 'rev-parse', '--git-dir'],
            capture_output=True, check=True, cwd=Path.cwd()
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def get_current_commit() -> str | None:
    """Get current HEAD commit SHA."""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'],
            capture_output=True, text=True, check=True, cwd=Path.cwd()
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None


def get_changed_files(since_commit: str) -> tuple[list[str], list[str]]:
    """Get changed and deleted files since a commit.

    Returns: (changed_files, deleted_files)
    """
    changed = []
    deleted = []

    try:
        # Changed/added files
        result = subprocess.run(
            ['git', 'diff', '--name-only', since_commit, 'HEAD'],
            capture_output=True, text=True, check=True, cwd=Path.cwd()
        )
        changed = [f for f in result.stdout.strip().split('\n') if f]

        # Deleted files
        result = subprocess.run(
            ['git', 'diff', '--name-only', '--diff-filter=D', since_commit, 'HEAD'],
            capture_output=True, text=True, check=True, cwd=Path.cwd()
        )
        deleted = [f for f in result.stdout.strip().split('\n') if f]

    except (subprocess.CalledProcessError, FileNotFoundError):
        pass

    return changed, deleted


def get_commits_behind(since_commit: str) -> int:
    """Get number of commits between since_commit and HEAD."""
    try:
        result = subprocess.run(
            ['git', 'rev-list', '--count', f'{since_commit}..HEAD'],
            capture_output=True, text=True, check=True, cwd=Path.cwd()
        )
        return int(result.stdout.strip())
    except (subprocess.CalledProcessError, FileNotFoundError, ValueError):
        return -1


def get_branch_name() -> str:
    """Get current branch name."""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
            capture_output=True, text=True, check=True, cwd=Path.cwd()
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return "unknown"
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add git integration helpers"
```

---

## Task 6: Add Index State Management

**Files:**
- Modify: `scripts/twin-mind.py` (add after git helpers)

**Step 1: Add index state functions**

```python
# === Index State ===
INDEX_STATE_FILE = "index-state.json"


def get_index_state_path() -> Path:
    return get_brain_dir() / INDEX_STATE_FILE


def load_index_state() -> dict | None:
    """Load index state from file."""
    state_path = get_index_state_path()
    if not state_path.exists():
        return None
    try:
        with open(state_path, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return None


def save_index_state(commit: str, file_count: int):
    """Save index state to file."""
    state = {
        "last_commit": commit,
        "indexed_at": datetime.now().isoformat(),
        "file_count": file_count
    }
    state_path = get_index_state_path()
    with open(state_path, 'w') as f:
        json.dump(state, f, indent=2)


def get_index_age() -> str | None:
    """Get human-readable index age."""
    state = load_index_state()
    if not state or "indexed_at" not in state:
        return None

    try:
        indexed_at = datetime.fromisoformat(state["indexed_at"])
        delta = datetime.now() - indexed_at

        if delta.days > 0:
            return f"{delta.days}d ago"
        elif delta.seconds >= 3600:
            return f"{delta.seconds // 3600}h ago"
        elif delta.seconds >= 60:
            return f"{delta.seconds // 60}m ago"
        else:
            return "just now"
    except (ValueError, KeyError):
        return None
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add index state management"
```

---

## Task 7: Refactor cmd_index for Incremental Support

**Files:**
- Modify: `scripts/twin-mind.py` (replace cmd_index function)

**Step 1: Replace the entire cmd_index function**

Find `def cmd_index(args):` and replace the entire function with:

```python
def cmd_index(args):
    """Index codebase into code store."""
    check_memvid()

    config = get_config()
    code_path = get_code_path()

    # Initialize colors based on config
    if not config["output"]["color"] or not supports_color():
        Colors.disable()

    if not get_brain_dir().exists():
        print(error("‚ùå Twin-Mind not initialized. Run: twin-mind init"))
        sys.exit(1)

    # Determine indexing mode
    incremental = False
    changed_files = []
    deleted_files = []
    state = load_index_state()

    if args.fresh:
        # Fresh index requested
        if code_path.exists():
            print(info("üîÑ Fresh index requested, resetting code store..."))
            code_path.unlink()
    elif state and is_git_repo():
        # Try incremental
        last_commit = state.get("last_commit")
        if last_commit:
            commits_behind = get_commits_behind(last_commit)
            if commits_behind == 0:
                print(success("‚úÖ Index is up to date (no new commits)"))
                return
            elif commits_behind > 0:
                changed_files, deleted_files = get_changed_files(last_commit)
                if changed_files or deleted_files:
                    incremental = True
                    print(info(f"üìÇ Incremental index (since {last_commit[:7]})"))
                    print(f"   Changed: {len(changed_files)} files")
                    print(f"   Deleted: {len(deleted_files)} files")
                else:
                    print(success("‚úÖ Index is up to date"))
                    return

    # Dry run mode
    if getattr(args, 'dry_run', False):
        if incremental:
            print("\n   Would reindex:")
            for f in changed_files[:10]:
                print(f"   + {f}")
            if len(changed_files) > 10:
                print(f"   ... and {len(changed_files) - 10} more")
        else:
            codebase_root = Path.cwd()
            extensions = get_extensions(config)
            skip_dirs = get_skip_dirs(config)
            max_size = parse_size(config["max_file_size"])

            files = collect_files(codebase_root, extensions, skip_dirs, max_size)
            print(f"\n   Would index {len(files)} files")
            for f in files[:10]:
                print(f"   + {f.relative_to(codebase_root)}")
            if len(files) > 10:
                print(f"   ... and {len(files) - 10} more")
        return

    # Open or create store
    if code_path.exists():
        if not incremental:
            print(info("üìù Appending to existing code index..."))
            print("   (Use --fresh for clean reindex)")
        mem = Memvid.open(str(code_path))
    else:
        mem = Memvid.create(str(code_path))

    # Use file locking for writes
    with FileLock(code_path):
        if incremental:
            indexed = index_files_incremental(mem, changed_files, config, args)
        else:
            indexed = index_files_full(mem, config, args)

        mem.commit()

    # Save state
    current_commit = get_current_commit()
    if current_commit:
        save_index_state(current_commit, indexed)

    print(f"\n{success('‚úÖ')} Indexed {indexed} files")
    print(f"   üì¶ Size: {format_size(code_path.stat().st_size)}")


def collect_files(root: Path, extensions: set, skip_dirs: set, max_size: int) -> list[Path]:
    """Collect all indexable files."""
    files = []
    for item in root.rglob('*'):
        if item.is_file():
            parts = item.relative_to(root).parts
            if any(p.startswith('.') or p in skip_dirs for p in parts):
                continue
            if item.suffix.lower() in extensions:
                if item.stat().st_size <= max_size:
                    files.append(item)
    return files


def index_files_full(mem, config: dict, args) -> int:
    """Full reindex of all files."""
    codebase_root = Path.cwd()
    extensions = get_extensions(config)
    skip_dirs = get_skip_dirs(config)
    max_size = parse_size(config["max_file_size"])
    verbose = config["output"]["verbose"] or getattr(args, 'verbose', False)

    print(f"üìÇ Scanning: {codebase_root}")
    files = collect_files(codebase_root, extensions, skip_dirs, max_size)
    print(f"   Found {len(files)} files")

    if not files:
        print(warning("   No indexable files found!"))
        return 0

    progress = ProgressBar(len(files), prefix="üìÇ Indexing: ")
    indexed = 0

    for filepath in files:
        try:
            relative_path = filepath.relative_to(codebase_root)
            content = filepath.read_text(encoding='utf-8', errors='ignore')

            if not content.strip():
                progress.update()
                continue

            opts = PutOptions.builder() \
                .title(str(relative_path)) \
                .uri(f"file://{relative_path}") \
                .tag("extension", filepath.suffix) \
                .tag("language", detect_language(filepath.suffix)) \
                .tag("indexed_at", datetime.now().isoformat()) \
                .build()

            mem.put_bytes_with_options(content.encode('utf-8'), opts)
            indexed += 1

            if verbose:
                print(f"   + {relative_path}")

        except Exception as e:
            if verbose:
                print(warning(f"   ‚ö†Ô∏è  Skip {filepath}: {e}"))

        progress.update()

    progress.finish()
    return indexed


def index_files_incremental(mem, changed_files: list[str], config: dict, args) -> int:
    """Incremental reindex of changed files only."""
    codebase_root = Path.cwd()
    extensions = get_extensions(config)
    max_size = parse_size(config["max_file_size"])
    verbose = config["output"]["verbose"] or getattr(args, 'verbose', False)

    indexed = 0

    for rel_path in changed_files:
        filepath = codebase_root / rel_path

        if not filepath.exists():
            continue

        if filepath.suffix.lower() not in extensions:
            continue

        if filepath.stat().st_size > max_size:
            continue

        try:
            content = filepath.read_text(encoding='utf-8', errors='ignore')
            if not content.strip():
                continue

            opts = PutOptions.builder() \
                .title(rel_path) \
                .uri(f"file://{rel_path}") \
                .tag("extension", filepath.suffix) \
                .tag("language", detect_language(filepath.suffix)) \
                .tag("indexed_at", datetime.now().isoformat()) \
                .build()

            mem.put_bytes_with_options(content.encode('utf-8'), opts)
            indexed += 1

            if verbose:
                print(f"   + {rel_path}")

        except Exception as e:
            if verbose:
                print(warning(f"   ‚ö†Ô∏è  Skip {rel_path}: {e}"))

    return indexed
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: implement incremental git-based indexing"
```

---

## Task 8: Implement Prune Command

**Files:**
- Modify: `scripts/twin-mind.py` (replace cmd_prune function)

**Step 1: Replace the entire cmd_prune function**

```python
def cmd_prune(args):
    """Prune old memories via filtered rebuild."""
    check_memvid()

    memory_path = get_memory_path()

    if not memory_path.exists():
        print(error("‚ùå No memory store. Run: twin-mind init"))
        sys.exit(1)

    # Parse date filter
    cutoff = None
    if args.before:
        if re.match(r'^\d+d$', args.before):
            days = int(args.before[:-1])
            cutoff = datetime.now() - timedelta(days=days)
        elif re.match(r'^\d+w$', args.before):
            weeks = int(args.before[:-1])
            cutoff = datetime.now() - timedelta(weeks=weeks)
        else:
            try:
                cutoff = datetime.fromisoformat(args.before)
            except ValueError:
                print(error(f"‚ùå Invalid date format: {args.before}"))
                print("   Use: YYYY-MM-DD, 30d (days), or 2w (weeks)")
                sys.exit(1)

    if not cutoff and not args.tag:
        print(error("‚ùå Specify --before DATE or --tag TAG to prune"))
        sys.exit(1)

    # Load all memories
    mem = Memvid.open(str(memory_path))
    req = SearchRequest(query="*", top_k=100000, snippet_chars=10000)
    response = mem.search(req)

    if not response.hits:
        print("üì≠ No memories to prune")
        return

    # Filter memories to remove
    to_remove = []
    to_keep = []

    for hit in response.hits:
        should_remove = False

        # Check date filter
        if cutoff and hit.uri:
            # Try to extract timestamp from URI or tags
            try:
                # URI format: twin-mind://memory/YYYYMMDD_HHMMSS
                if "twin-mind://memory/" in hit.uri:
                    date_part = hit.uri.split("/")[-1]
                    mem_date = datetime.strptime(date_part, "%Y%m%d_%H%M%S")
                    if mem_date < cutoff:
                        should_remove = True
            except (ValueError, IndexError):
                pass

        # Check tag filter
        if args.tag and hit.uri:
            # Skip system entries
            if "twin-mind://system" in hit.uri:
                to_keep.append(hit)
                continue
            # This is a simplified check - actual tag matching depends on memvid-sdk
            if args.tag.lower() in hit.text.lower() or args.tag.lower() in (hit.title or "").lower():
                should_remove = True

        if should_remove:
            to_remove.append(hit)
        else:
            to_keep.append(hit)

    if not to_remove:
        print(success("‚úÖ No memories match prune criteria"))
        return

    # Show preview
    print(f"\nüîç Prune preview:")
    print(f"   Matching: {len(to_remove)} memories")
    for hit in to_remove[:5]:
        title = (hit.title or "untitled")[:50]
        print(f"   - \"{title}\"")
    if len(to_remove) > 5:
        print(f"   ... and {len(to_remove) - 5} more")

    # Dry run stops here
    if getattr(args, 'dry_run', False):
        print(f"\n   Would keep {len(to_keep)} memories")
        return

    # Confirm
    if not args.force:
        if not confirm(f"\n‚ö†Ô∏è  Delete {len(to_remove)} memories?"):
            print("   Cancelled")
            return

    # Backup
    backup_path = Path(str(memory_path) + '.backup')
    import shutil
    shutil.copy2(memory_path, backup_path)
    print(f"üíæ Backed up to {backup_path}")

    # Rebuild with kept memories
    memory_path.unlink()
    new_mem = Memvid.create(str(memory_path))

    for hit in to_keep:
        opts = PutOptions.builder() \
            .title(hit.title or "untitled") \
            .uri(hit.uri or f"twin-mind://memory/{datetime.now().strftime('%Y%m%d_%H%M%S')}") \
            .build()
        new_mem.put_bytes_with_options(hit.text.encode('utf-8'), opts)

    new_mem.commit()

    print(success(f"‚úÖ Pruned {len(to_remove)} memories ({len(to_keep)} remaining)"))
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: implement prune command with filtered rebuild"
```

---

## Task 9: Add Status Command

**Files:**
- Modify: `scripts/twin-mind.py` (add new command function before main)

**Step 1: Add cmd_status function**

Add before `def main():`:

```python
def cmd_status(args):
    """Show twin-mind health status."""
    check_memvid()

    config = get_config()
    if not config["output"]["color"] or not supports_color():
        Colors.disable()

    code_path = get_code_path()
    memory_path = get_memory_path()

    print(f"\nüß† Twin-Mind Status")
    print("‚ïê" * 50)

    # Code stats
    if code_path.exists():
        code_size = format_size(code_path.stat().st_size)
        try:
            mem = Memvid.open(str(code_path))
            code_count = len(mem.search(SearchRequest(query="*", top_k=10000)).hits)
        except Exception:
            code_count = "?"

        age = get_index_age() or "unknown"
        print(f"üìÑ Code     {code_size:>8} ‚îÇ {code_count} files ‚îÇ indexed {age}")
    else:
        print(f"üìÑ Code     {warning('not created')}")

    # Memory stats
    if memory_path.exists():
        mem_size = format_size(memory_path.stat().st_size)
        try:
            mem = Memvid.open(str(memory_path))
            mem_count = len(mem.search(SearchRequest(query="*", top_k=10000)).hits)
        except Exception:
            mem_count = "?"
        print(f"üìù Memory   {mem_size:>8} ‚îÇ {mem_count} entries")
    else:
        print(f"üìù Memory   {warning('not created')}")

    # Git status
    if is_git_repo():
        branch = get_branch_name()
        commit = get_current_commit()
        commit_short = commit[:7] if commit else "?"

        state = load_index_state()
        if state and commit:
            behind = get_commits_behind(state.get("last_commit", commit))
            if behind > 0:
                git_status = warning(f"{behind} commits ahead of index")
            elif behind == 0:
                git_status = success("up to date")
            else:
                git_status = "unknown"
        else:
            git_status = "not indexed yet"

        print(f"üîó Git      {branch} @ {commit_short} ({git_status})")

    print("‚ïê" * 50)


def cmd_reindex(args):
    """Reset code and reindex (convenience command)."""
    # Set up args for reset
    args.target = 'code'
    args.force = True
    cmd_reset(args)

    # Set up args for index
    args.fresh = True
    args.dry_run = False
    args.verbose = getattr(args, 'verbose', False)
    cmd_index(args)
```

**Step 2: Update argument parser in main()**

Find the `# stats` subparser section and add after it:

```python
    # status
    subparsers.add_parser('status', help='Show twin-mind health status')

    # reindex
    p_reindex = subparsers.add_parser('reindex', help='Reset code and reindex fresh')
    p_reindex.add_argument('--verbose', '-v', action='store_true', help='Show each file')
```

**Step 3: Update commands dict**

Find `commands = {` and add:

```python
        'status': cmd_status,
        'reindex': cmd_reindex,
```

**Step 4: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 5: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add status and reindex convenience commands"
```

---

## Task 10: Add CLI Flags (--verbose, --dry-run, --no-color)

**Files:**
- Modify: `scripts/twin-mind.py` (update argument parsers)

**Step 1: Update index parser**

Find `p_index = subparsers.add_parser('index'` and update:

```python
    # index
    p_index = subparsers.add_parser('index', help='Index codebase')
    p_index.add_argument('--fresh', '-f', action='store_true',
                         help='Delete existing index and rebuild from scratch')
    p_index.add_argument('--dry-run', action='store_true',
                         help='Show what would be indexed without doing it')
    p_index.add_argument('--verbose', '-v', action='store_true',
                         help='Show each file being indexed')
    p_index.add_argument('--status', action='store_true',
                         help='Show what would be reindexed')
```

**Step 2: Update reset parser**

Find `p_reset = subparsers.add_parser('reset'` and update:

```python
    # reset
    p_reset = subparsers.add_parser('reset', help='Reset a memory store')
    p_reset.add_argument('target', choices=['code', 'memory', 'all'], help='What to reset')
    p_reset.add_argument('--force', '-f', action='store_true', help='Skip confirmation')
    p_reset.add_argument('--dry-run', action='store_true', help='Show what would be reset')
```

**Step 3: Update prune parser**

Find `p_prune = subparsers.add_parser('prune'` and update:

```python
    # prune
    p_prune = subparsers.add_parser('prune', help='Prune old memories')
    p_prune.add_argument('target', choices=['memory'], help='What to prune')
    p_prune.add_argument('--before', '-b', help='Remove before date (YYYY-MM-DD, 30d, 2w)')
    p_prune.add_argument('--tag', '-t', help='Remove by tag')
    p_prune.add_argument('--dry-run', action='store_true', help='Preview without deleting')
    p_prune.add_argument('--force', '-f', action='store_true', help='Skip confirmation')
```

**Step 4: Add global --no-color flag**

Find `parser.add_argument('--version'` and add after it:

```python
    parser.add_argument('--no-color', action='store_true', help='Disable colored output')
```

**Step 5: Handle --no-color in main()**

After `args = parser.parse_args()` add:

```python
    # Handle global flags
    if args.no_color:
        Colors.disable()
```

**Step 6: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 7: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add --verbose, --dry-run, --no-color CLI flags"
```

---

## Task 11: Improve Search with --context and --full

**Files:**
- Modify: `scripts/twin-mind.py` (update cmd_search)

**Step 1: Update search parser**

Find `p_search = subparsers.add_parser('search'` and update:

```python
    # search
    p_search = subparsers.add_parser('search', help='Search twin-mind')
    p_search.add_argument('query', help='Search query')
    p_search.add_argument('--in', dest='scope', choices=['code', 'memory', 'all'],
                          default='all', help='Where to search (default: all)')
    p_search.add_argument('--top-k', '-k', type=int, default=10, help='Number of results')
    p_search.add_argument('--json', '-j', action='store_true', help='Output as JSON')
    p_search.add_argument('--context', '-c', type=int, default=0,
                          help='Lines of context around matches')
    p_search.add_argument('--full', action='store_true', help='Show full content')
```

**Step 2: Update cmd_search JSON output**

In `cmd_search`, update the JSON output section:

```python
    # JSON output
    if args.json:
        output = {
            "query": args.query,
            "results": [],
            "meta": {
                "index_age": get_index_age(),
                "scope": args.scope
            }
        }
        for source, hit in results:
            result_item = {
                "source": source,
                "title": hit.title,
                "score": hit.score,
                "uri": hit.uri,
            }
            if args.full:
                result_item["content"] = hit.text
            else:
                result_item["snippet"] = hit.text.strip()[:300]
            output["results"].append(result_item)
        print(json.dumps(output, indent=2))
        return
```

**Step 3: Update search display for --context**

In `cmd_search`, update the display section:

```python
    for i, (source, hit) in enumerate(results, 1):
        icon = "üìÑ" if source == 'code' else "üìù"
        title = hit.title or "untitled"

        print(f"\n{icon} [{i}] {title}")
        print(f"   Score: {hit.score:.3f} | Source: {source}")
        print("-" * 40)

        if args.full:
            print(hit.text)
        else:
            snippet_chars = 300 + (args.context * 80)  # More chars for context
            snippet = hit.text.strip()[:snippet_chars]
            max_lines = 8 + args.context
            indented = "\n".join(f"   {line}" for line in snippet.split("\n")[:max_lines])
            print(indented)
```

**Step 4: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 5: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add --context and --full flags to search"
```

---

## Task 12: Add Stale Index Warning

**Files:**
- Modify: `scripts/twin-mind.py` (update cmd_search)

**Step 1: Add stale warning at start of cmd_search**

At the beginning of `cmd_search`, after `check_memvid()`:

```python
def cmd_search(args):
    """Search code, memory, or both."""
    check_memvid()

    config = get_config()
    if not config["output"]["color"] or not supports_color():
        Colors.disable()

    # Check for stale index
    if args.scope in ('code', 'all') and is_git_repo():
        state = load_index_state()
        if state:
            behind = get_commits_behind(state.get("last_commit", ""))
            if behind > 10:
                print(warning(f"‚ö†Ô∏è  Index may be stale ({behind} commits behind)"))
                print(f"   Run: twin-mind index\n")
            age = get_index_age()
            if age and 'd' in age:  # More than a day old
                days = int(age.replace('d ago', ''))
                if days > 1:
                    print(warning(f"‚ö†Ô∏è  Index is {age}"))
                    print(f"   Run: twin-mind index\n")
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add stale index warning in search"
```

---

## Task 13: Add Context Command for Claude Code

**Files:**
- Modify: `scripts/twin-mind.py` (add new command)

**Step 1: Add cmd_context function**

Add before `def main():`:

```python
def cmd_context(args):
    """Get combined code + memory context for AI prompts."""
    check_memvid()

    code_path = get_code_path()
    memory_path = get_memory_path()

    results = {
        "query": args.query,
        "code": [],
        "memory": [],
        "meta": {
            "index_age": get_index_age(),
            "timestamp": datetime.now().isoformat()
        }
    }

    # Search code
    if code_path.exists():
        mem = Memvid.open(str(code_path))
        req = SearchRequest(query=args.query, top_k=args.top_k, snippet_chars=1000)
        response = mem.search(req)
        for hit in response.hits:
            results["code"].append({
                "file": hit.title,
                "score": hit.score,
                "content": hit.text.strip()
            })

    # Search memory
    if memory_path.exists():
        mem = Memvid.open(str(memory_path))
        req = SearchRequest(query=args.query, top_k=args.top_k, snippet_chars=1000)
        response = mem.search(req)
        for hit in response.hits:
            results["memory"].append({
                "title": hit.title,
                "score": hit.score,
                "content": hit.text.strip()
            })

    print(json.dumps(results, indent=2))
```

**Step 2: Add parser**

Add after other subparsers:

```python
    # context
    p_context = subparsers.add_parser('context', help='Get combined context for AI prompts')
    p_context.add_argument('query', help='Search query')
    p_context.add_argument('--top-k', '-k', type=int, default=5, help='Results per store')
```

**Step 3: Add to commands dict**

```python
        'context': cmd_context,
```

**Step 4: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 5: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "feat: add context command for Claude Code integration"
```

---

## Task 14: Update Version

**Files:**
- Modify: `scripts/twin-mind.py`

**Step 1: Update VERSION constant**

Find `VERSION = "1.0.0"` and change to:

```python
VERSION = "1.1.0"
```

**Step 2: Verify syntax**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 3: Commit**

```bash
git add scripts/twin-mind.py
git commit -m "chore: bump version to 1.1.0"
```

---

## Task 15: Update Documentation

**Files:**
- Modify: `SKILL.md`
- Modify: `README.md`
- Create: `CHANGELOG.md`
- Create: `LICENSE`

**Step 1: Update SKILL.md**

Add new commands to the Commands table:

```markdown
| `status` | Health check with git state |
| `reindex` | Reset code and reindex fresh |
| `context <query>` | Combined context for AI (JSON) |
```

Add new flags section:

```markdown
## Flags

| Flag | Commands | Purpose |
|------|----------|---------|
| `--dry-run` | index, reset, prune | Preview without executing |
| `--verbose` / `-v` | index | Show each file processed |
| `--context N` | search | Lines of context around matches |
| `--full` | search | Show full file content |
| `--no-color` | all | Disable colored output |
```

**Step 2: Create CHANGELOG.md**

```markdown
# Changelog

## [1.1.0] - 2025-01-22

### Added
- Configuration via `.claude/settings.json`
- Git-based incremental indexing
- Prune command with date/tag filters
- `status` command for health check
- `reindex` convenience command
- `context` command for AI integration
- `--dry-run` flag for index, reset, prune
- `--verbose` flag for detailed output
- `--context` and `--full` flags for search
- `--no-color` flag for plain output
- Progress bar for indexing
- Colored output (auto-detected)
- File locking for concurrent safety
- Stale index warnings
- Index state tracking

### Changed
- `index` now does incremental update by default
- Improved error messages with recovery hints

### Fixed
- Prune command now works (was "not implemented")

## [1.0.0] - 2025-01-22

- Initial release
```

**Step 3: Create LICENSE**

```
MIT License

Copyright (c) 2025 Twin-Mind Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

**Step 4: Update README.md Configuration section**

Add after "Quick Start" section:

```markdown
## Configuration

Twin-Mind can be configured via `.claude/settings.json`:

\`\`\`json
{
  "twin-mind": {
    "extensions": {
      "include": [".custom"],
      "exclude": [".min.js"]
    },
    "skip_dirs": ["my_custom_dir"],
    "max_file_size": "500KB",
    "output": {
      "color": true,
      "verbose": false
    }
  }
}
\`\`\`

All settings are optional ‚Äî sensible defaults apply.
```

**Step 5: Commit all docs**

```bash
git add SKILL.md README.md CHANGELOG.md LICENSE
git commit -m "docs: update documentation for v1.1.0"
```

---

## Task 16: Final Verification

**Step 1: Run full syntax check**

Run: `python -m py_compile scripts/twin-mind.py`
Expected: No output (success)

**Step 2: Test help output**

Run: `python scripts/twin-mind.py --help`
Expected: Shows all commands including new ones

**Step 3: Test version**

Run: `python scripts/twin-mind.py --version`
Expected: `twin-mind 1.1.0`

**Step 4: Final commit (if any uncommitted changes)**

```bash
git status
# If clean, done. Otherwise:
git add -A
git commit -m "chore: final v1.1.0 cleanup"
```

---

## Summary

Total tasks: 16
Estimated commits: ~17

New features:
- Configuration system
- Incremental indexing
- Prune command
- Status/reindex commands
- Context command
- Progress bar
- Colored output
- Dry-run support
- Verbose mode
- File locking
- Stale warnings
